#!/bin/bash
#
# usage: junc [-p] [-d] [-j junction-root] [-c name-length] [dir-path]

set -e

NC='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
YELLOW='\033[1;33m'

push_junc=false
pop_junc=false
junc_root="/c/junc"
name_length=5
dir_path="$PWD"


usage_short="${BLUE}usage: junc [-p] [-d] [-j junction-root] [-c name-length] [dir-path]"
usage_long="$usage_short\n-p: create junction and push directory to top of stack (default: $push_junc)"
usage_long="$usage_long\n-d: delete junction at path and pop from stack (default: $pop_junc)"
usage_long="$usage_long\n-j: path to junction root (default: $junc_root)"
usage_long="$usage_long\n-c: length of randomly generated junction names (default: $name_length)"
usage_long="$usage_long\ndir-path: path to the directory getting junctioned (default: $dir_path)${NC}"

usage_short="$usage_short\nuse -h to get supported command information.${NC}"

options=":pdj:c:h"
shopt -u nocasematch
OPTIND=1
while getopts "$options" opt ; do
    case "$opt" in
    p )
      push_junc=true
      ;;
    d )
      pop_junc=true
      ;;
    j )
      junc_root="$OPTARG"
      ;;
    c )
      name_length="$OPTARG"
      ;;
    h )
      >&2 echo -e "$usage_long" && exit 1
      exit 0
      ;;
    \?)
      >&2 echo -e "Unknown option: -$OPTARG"
      >&2 echo -e "$usage_short"
      exit 1
      ;;
    : )
      >&2 echo -e "Missing option argument for -$OPTARG"
      >&2 echo -e "$usage_short"
      exit 1
      ;;
    * )
      >&2 echo -e "Unimplemented option: -$OPTARG" && exit 1
      >&2 echo -e "$usage_short"
      exit 1
    esac
done
shift $((OPTIND-1))

if [ "$1" != "" ] ; then
  dir_path="$1"
  shift
fi

if [ "$push_junc" = true ] && [ "$pop_junc" = true ] ; then
  >&2 echo -e "${RED}- Can push (-p) or pop (-d) but not both -${NC}"
  exit 1
fi

generate_name() {
  < /dev/urandom tr -dc a-z | head -c${1:-32};echo;
}

to_win_path() {
  if [ "$1" ] ; then
    # handle absolute
    if [[ "$1" == /* ]] ; then
      # strip leading slash and convert to backslash
      win_path=$(echo "$1" | sed -e 's/^\///'  -e 's/\//\\\\/g')
      # Add semicolon after drive
      win_path=$(echo "${win_path:0:1}:${win_path:1}")
      echo -n "$win_path"
    else
      # convert to backslash
      win_path=$(echo "$1" | sed 's/\//\\\\/g')
      echo -n "$win_path"
    fi
  fi
}

win_dir_path="$(to_win_path "$dir_path")"

# If -d flag specified, remove and echo for popd and other commands->
if [ "$pop_junc" = true ] ; then
  cmd //c rmdir "$win_dir_path"
  echo "$win_dir_path"
  exit 0
fi

# Perform junction, loop in case random returns the same name twice
junc_name="$(generate_name "$name_length")"
junc_path="$junc_root/$junc_name"
while [ -e "$junc_path" ] ; do
  junc_name="$(generate_name "$name_length")"
  junc_path="$junc_root/$junc_name"
done

win_junc_path="$(to_win_path "$junc_path")"

mkdir -p "$junc_root"
cmd //c mklink //J "$win_junc_path" "$win_dir_path"

# If -p flag specified, echo for pushd ->
if [ "$push_junc" = true ] ; then
  echo "$junc_path"
  exit 0
fi
